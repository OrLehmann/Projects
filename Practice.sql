--1. Find the total revenue generated by each product, considering discounts. Display the ProductName, UnitPrice, Quantity, and the TotalRevenue as a calculated column.
select p.ProductName, od.UnitPrice, od.Quantity, od.UnitPrice*(1-od.Discount)*od.Quantity AS TotalRevenue
from [Order Details] od join Products p ON p.productID = od.productID;
GO

--2. Retrieve a list of all customers along with their orders (if any), showing CustomerID, CompanyName, OrderID, and OrderDate. Ensure that customers with no orders are still included.
select o.CustomerID, c.CompanyName, o.OrderID, o.OrderDate
from orders o right join Customers c ON o.customerID = c.customerID;
GO

--3. Show all employees who have the word "Manager" in their Title. Include their EmployeeID, FirstName, and LastName.
select EmployeeID, FirstName, LastName
from employees e 
Where Title LIKE '%Manager%'
GO

--4. Find all customers who have made orders between '1997-01-01' and '1997-12-31'. Display their CustomerID, CompanyName, and ensure no duplicate customers are included.
select Distinct o.CustomerID, c.CompanyName 
from orders o join customers c ON o.CustomerID = c.CustomerID
Where o.OrderDate > '1997-01-01' AND o.OrderDate < '1997-12-31'
GO

--5. Retrieve all orders that contain products with a unit price above the average unit price of all products.
select od.OrderID
from [Order details] od,
(
select AVG(od1.UnitPrice) AS AveragePrice
		from [Order details] od1
		) AS T1
where od.UnitPrice > T1.AveragePrice;
GO

--same assignment (5) with CTE's
WITH AveragePrice AS (
    SELECT AVG(od1.UnitPrice) AS AvgUnitPrice
    FROM [Order Details] od1
)
SELECT distinct od.OrderID
FROM [Order Details] od join orders o ON o.orderID = od.OrderID
CROSS JOIN AveragePrice
WHERE od.UnitPrice > AveragePrice.AvgUnitPrice;
GO

--6.Display all orders for which there is no matching customer in the Customers table. Include the OrderID and the CustomerID of these orders.
select o.OrderID, o.CustomerID
from orders o left join customers c ON o.customerID = c.customerID
where c.customerID IS NULL
GO
--7. Find all products supplied by suppliers located in the same country as the customers who ordered them. Show SupplierID, CustomerID, and ProductName.
select distinct p.ProductName
from [Order Details] od JOIN orders o ON o.OrderID = od.orderID JOIN Products p ON od.ProductID = p.productID JOIN Suppliers s ON p.SupplierID = s.SupplierID
where s.Country = o.ShipCountry
GO

--8. 8.	Display all employees along with their territories (if any). Include EmployeeID, FirstName, LastName, and TerritoryDescription. Show employees even if they are not assigned to any territories.
	select e.EmployeeID, e.FirstName,e.LastName, t.TerritoryDescription
	from employees e left join employeeTerritories et ON e.employeeID = et.employeeID left JOIN Territories t ON et.TerritoryID = t.TerritoryID
	GO

--9.	Find customers who placed all their orders after '1998-01-01'. Display their CustomerID and CompanyName.
select distinct c.CustomerID, c.CompanyName
from orders o join customers c ON o.customerID = c.customerID
where o.OrderDate > '1998-01-01'

--10.For each product category, find the total number of products and the average unit price. Display CategoryID, CategoryName, TotalProducts, and AverageUnitPrice.
select c.categoryID, c.CategoryName, count(p.productID) as TotalProducts, AVG(od.unitprice) as averageunitprice
from categories c join products p ON c.CategoryID = p.CategoryID join [order details] od ON p.productID = od.productID
group by c.CategoryName, c.CategoryID
GO

--11.Retrieve the names of all products that have never been ordered. Display the ProductName and ProductID.
with productdifferent AS (
select p.ProductID
from products p 
EXCEPT
select od.ProductID
from [order details] od
)
select p.ProductName, p.ProductID, pd.ProductID
from products p join productdifferent pd ON p.ProductID = pd.ProductID
GO

--12.Display the OrderID and the total number of distinct products in each order where the total number of products is more than 5.
select OrderID, count(distinct productID) as numofproducts
from [Order Details]
group by orderID
HAVING count(distinct productID) > 5
GO

--13.Find all suppliers who have provided products priced higher than every product supplied by Exotic Liquids. Display their SupplierID and CompanyName.
select distinct s.SupplierID,s.CompanyName
from suppliers s JOIN products p ON s.supplierID = p.supplierID 
WHERE UnitPrice > ALL(
	select p1.UnitPrice
	from suppliers s1 JOIN products p1 ON s1.supplierID = p1.supplierID 
	where s1.CompanyName = 'Exotic Liquids'
	)
	GO

--14.Retrieve all employees who do not report to anyone (i.e., they are not assigned a manager). Include their EmployeeID and FullName (calculated as FirstName + LastName).
select e.EmployeeID, (e.FirstName + '' + e.LastName) AS Fullname 
from employees e
where ReportsTo IS NULL
GO

--15.For every CustomerID that has made an order, display the OrderID, ProductName, and the total cost of the order (UnitPrice * Quantity), considering discounts.
select o.CustomerID, o.orderID, p.ProductName, od.unitprice*od.quantity*(1-od.discount) AS totalcostoforder
from orders o join [order details] od ON o.orderID = od.orderID JOIN Products p ON od.ProductID = p.ProductID
GO
--16.Find the customers who have made orders with all available products. Display their CustomerID and CompanyName.
select o.customerID
from orders o
where not exists(
	select p.ProductID
	from products p
	where not exists(
		select od.OrderID
		from [Order Details] od
		where o.OrderID = od.OrderID AND p.ProductID = od.ProductID)
		)
GO

--17.Retrieve the top 3 most expensive products in each category. Display CategoryID, CategoryName, ProductID, ProductName, and UnitPrice.
with RankedProducts AS (
	select c.CategoryID, c.CategoryName, p.ProductID,p.ProductName,p.UnitPrice,
	Row_number() Over(Partition by c.categoryName order by p.unitprice Desc) AS row_unitprice
	from products p join Categories c ON p.CategoryID = c.CategoryID
	)
	select rp.categoryID, rp.categoryName, rp.productID, rp.productName, rp.unitprice
	from RankedProducts rp
	where row_unitprice <= 3
GO

--18. For each employee, count the number of territories they are assigned to. Display EmployeeID, FullName (concatenation of FirstName and LastName), and the total number of territories. Then, find the employee assigned to the highest number of territories.

With employeesTerritoryCount AS(
select e.EmployeeID, (e.FirstName + '' + e.LastName) AS FullName, 
count(et.territoryID) AS TerritoryCount
from employeeTerritories et JOIN employees e ON et.employeeID = e.employeeID 
group by e.EmployeeID, e.FirstName, e.LastName
		)

		select ETC.EmployeeID, ETC.FullName, ETC.TerritoryCount
		from employeesTerritoryCount ETC
		Where ETC.TerritoryCount = (
				select MAX(TerritoryCount)
				from employeesTerritoryCount
				);

GO

--19.List all customers who have never placed an order. Display their CustomerID and CompanyName.
select c.customerID, c.CompanyName
from customers c left JOIN orders o ON c.customerID = o.CustomerID
where o.orderID IS NULL

GO

--20. For each order, display the OrderID, TotalProducts (number of distinct products in the order), and TotalRevenue. Filter the results to show only orders where TotalRevenue > 1000.
select o.OrderID, count(distinct od.ProductID) AS TotalProducts, SUM(od.Quantity*od.UnitPrice*(1-od.Discount)) AS TotalRevenue
from orders o JOIN [order details] od ON o.orderID = od.orderID
group by o.OrderID
HAVING SUM(od.Quantity*od.UnitPrice*(1-od.Discount)) > 1000


--21. Show the number of orders placed by each customer who has placed more than 10 orders. Display their CustomerID, CompanyName, and OrderCount.
select c.CustomerID, c.CompanyName, count(o.orderID) AS OrderCount
from customers c JOIN orders o ON c.customerID = o.customerID 
Group by c.CustomerID, c.CompanyName
HAVING count(o.orderID) > 10

GO

--22. Retrieve the SupplierID, CompanyName, and TotalProducts for suppliers who have supplied more than 5 products. Sort the result by TotalProducts in descending order.
select s.SupplierID, s.CompanyName, count(distinct p.productID) AS TotalProducts
from Suppliers s JOIN products p ON s.supplierID = p.supplierID
Group by s.SupplierID, s.CompanyName
HAVING count(p.productID) > 5
Order by count(distinct p.productID) DESC


GO

--23.List all employees who work in all territories within the RegionID = 1. Display their EmployeeID, FirstName, and LastName.

select e.EmployeeID, e.FirstName, e.LastName
from Employees e
Where NOT EXISTS(
	select t.TerritoryID
	from Territories t
	WHERE NOT EXISTS(
		select et.EmployeeID
		from EmployeeTerritories et
		Where e.EmployeeID = et.EmployeeID AND t.TerritoryID = et.TerritoryID AND t.RegionID = 1)
		);


--26.Find customers who have not placed any orders for products in the Beverages category. Display their CustomerID and CompanyName.
select Distinct o.CustomerID, c.CompanyName
from customers c JOIN orders o ON c.CustomerID = o.CustomerID JOIN [order details] od ON o.orderID = od.orderID JOIN products p ON p.productID = od.productID JOIN Categories ct ON p.CategoryID = ct.CategoryID
Where ct.CategoryName <> 'Beverages'

--* its not 100% correct, this is the new version that uses "NOT EXISTS" that is the correct way.

SELECT DISTINCT c.CustomerID, c.CompanyName
FROM Customers c
WHERE NOT EXISTS (
    SELECT *
    FROM Orders o
    JOIN [Order Details] od ON o.OrderID = od.OrderID
    JOIN Products p ON od.ProductID = p.ProductID
    JOIN Categories ct ON p.CategoryID = ct.CategoryID
    WHERE c.CustomerID = o.CustomerID AND ct.CategoryName = 'Beverages'
);


--27. Retrieve the total revenue for each category, considering discounts. Display CategoryID, CategoryName, and TotalRevenue.
select c.CategoryID, c.CategoryName, SUM(od.unitprice*od.quantity*(1-od.discount)) AS Total_revenue
from categories c JOIN products p ON c.categoryID = p.categoryID JOIN [order details] od ON p.productID = od.productID
group by c.CategoryID, c.CategoryName

GO

--28. For each employee, display the number of orders they have handled along with their FirstName and LastName. Include employees who have not handled any orders.
select e.FirstName,e.LastName, count(o.orderID) AS number_of_orders
from employees e left JOIN orders o ON e.employeeID = o.employeeID
group by e.EmployeeID,e.FirstName,e.LastName

GO

--29. Find all orders where the total revenue exceeds the average total revenue of all orders. Display the OrderID and TotalRevenue.

select od.orderID, 
	SUM(od.UnitPrice*od.Quantity*(1-od.Discount)) AS total_revenue
from [order details] od 
Group by od.OrderID
HAVING SUM(od.UnitPrice*od.Quantity*(1-od.Discount)) > (
	select AVG(od1.UnitPrice*od1.Quantity*(1-od1.Discount)) AS Average_total_revenue
	from [order details] od1
	);


	--30. Retrieve the list of CustomerID and CompanyName for customers who have placed orders for products supplied by all suppliers.

select c.CustomerID, c.CompanyName
from customers c 
where not exists(
	select s.SupplierID
	from Suppliers s
	where not exists(
		select od.orderID
		from orders o JOIN [Order Details] od ON o.orderID = od.orderID JOIN products p ON p.productID = od.productID 
		where c.CustomerID = o.CustomerID AND s.SupplierID = p.SupplierID)
		);


--Questions about window functions
--1.Calculate cumulative sales for each customer

WITH salesofcustomer AS (
    SELECT 
        o.CustomerID, 
        o.OrderID, 
        SUM(od.Quantity * od.UnitPrice * (1 - od.Discount)) AS Sales
    FROM [Order Details] od
    JOIN Orders o ON od.OrderID = o.OrderID
    GROUP BY o.CustomerID, o.OrderID
)
SELECT 
    sc.CustomerID,
    sc.OrderID,
    sc.Sales,
    SUM(sc.Sales) OVER (PARTITION BY sc.CustomerID ORDER BY sc.OrderID) AS CumulativeSales
FROM salesofcustomer sc
GO


--2.Display the CategoryID, CategoryName, the cheapest product, the most expensive product, and the average price of products in that category from the Products table.

With ProductsRank AS(
select c.CategoryID, c.CategoryName, p.productName, p.unitprice,
RANK() OVER(partition by c.categoryID order by p.unitprice DESC) AS most_expensive_products,
RANK() OVER(partition by c.categoryID order by p.unitprice ASC) AS the_cheapest,
AVG(p.unitprice) over(partition by c.categoryID) AS average_per_category
from categories c JOIN products p ON c.categoryID = p.categoryID 
)


select PR.CategoryID, PR.CategoryName, PR.ProductName, PR.UnitPrice, PR.most_expensive_products, PR.the_cheapest, PR.average_per_category
from productsRank PR
	Where PR.most_expensive_products = 1 OR PR.the_cheapest = 1
	order by PR.CategoryID, PR.UnitPrice DESC

	GO

--2. chat solution:

WITH ProductsRank AS (
    SELECT 
        c.CategoryID, 
        c.CategoryName, 
        p.ProductName, 
        p.UnitPrice,
        RANK() OVER (PARTITION BY c.CategoryID ORDER BY p.UnitPrice DESC) AS MostExpensiveRank,
        RANK() OVER (PARTITION BY c.CategoryID ORDER BY p.UnitPrice ASC) AS CheapestRank,
        AVG(p.UnitPrice) OVER (PARTITION BY c.CategoryID) AS AvgPrice
    FROM 
        Categories c 
    JOIN 
        Products p 
    ON 
        c.CategoryID = p.CategoryID 
)
SELECT 
    PR.CategoryID, 
    PR.CategoryName, 
    PR.ProductName, 
    PR.UnitPrice,
    CASE 
        WHEN PR.MostExpensiveRank = 1 THEN 'Most Expensive'
        WHEN PR.CheapestRank = 1 THEN 'Cheapest'
    END AS ProductType,
    PR.AvgPrice
FROM 
    ProductsRank PR
WHERE 
    PR.MostExpensiveRank = 1 OR PR.CheapestRank = 1
ORDER BY 
    PR.CategoryID, 
    PR.UnitPrice DESC;

	GO

--Advanced questions:

--1. Analyze Customer Spending Behavior
select c.CustomerID, c.CompanyName, sum(od.unitprice*od.quantity*(1-od.discount)) AS total_spending,
CASE 
	WHEN sum(od.unitprice*od.quantity*(1-od.discount)) > 20000 THEN 'High Spender'
	WHEN sum(od.unitprice*od.quantity*(1-od.discount)) >10000 AND sum(od.unitprice*od.quantity*(1-od.discount)) < 20000 THEN 'Moderate Spender'
	WHEN sum(od.unitprice*od.quantity*(1-od.discount)) < 10000 THEN 'Low Spender'
	END AS CustomerClassification
from customers c JOIN orders o ON c.customerID = o.customerID JOIN [order details] od ON o.orderID = od.orderID
group by c.CustomerID, c.CompanyName

GO

--2.Find Products Sold Above Average Price in Each Category
with AveragePerCategory AS (
select c.CategoryID,c.CategoryName,p.ProductID,p.ProductName, p.unitprice, AVG(p.unitprice) over(partition by c.categoryID) AS Average_of_category
from categories c JOIN products p ON c.categoryID = p.categoryID 
)

select APC.categoryID, APC.categoryName, APC.ProductID,APC.ProductName, APC.UnitPrice
from AveragePerCategory APC
WHERE APC.UnitPrice > Average_of_category

GO

--3. Identify Orders That Exceeded the Average Total Revenue, with derived table:
select o.orderID, SUM(od.unitprice*od.quantity*(1-od.discount)) AS total_revenue
from orders o JOIN [order details] od ON o.orderID = od.orderID 
group by o.orderID
HAVING SUM(od.unitprice*od.quantity*(1-od.discount)) > (
	select AVG(od1.unitprice*od1.quantity*(1-od1.discount)) AS Average_revenue
	from orders o1 JOIN [order details] od1 ON o1.orderID = od1.orderID)

	GO


--3. Identify Orders That Exceeded the Average Total Revenue, with CTE:
	
	With AverageRevenue AS(
	select o.orderID, AVG(od.unitprice*od.quantity*(1-od.discount)) AS Average_revenue,
	Sum(od.unitprice*od.quantity*(1-od.discount)) AS totalRevenue
	from orders o JOIN [order details] od ON o.orderID = od.orderID
	group by o.orderID
	)

	select AR.OrderID, 
	CASE
		When AR.Average_revenue < AR.totalRevenue THEN 'Above Average'
		ELSE 'Below Average' 
		END AS Classification 
	from AverageRevenue AR
